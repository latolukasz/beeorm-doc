# Lazy Flush

Executing `engine.Lazy()` executes all queries to MySQL and Redis immediately.
But in many scenarios you may prefer to run queries asynchronously, in another thread, so your code can continue
without a need to wait a query is executed in database.

BeeORM provides special method `FlushLazy()` which is doing exactly it. Queries to MySQL and Redis are added to special [redis stream](https://redis.io/docs/data-types/streams/) 
called `orm-lazy-channel`. Then [background consumer](/guide/background_consumer.html) is reading these queries and executes them.

Look at example below:

<code-group>
<code-block title="code">
```go{3,10,14,2-}
// adding new entity
user := &UserEntity{FirstName: "Tom", LastName: "Bee", Email: "bee@beeorm.io"}
engine.FlushLazy(user) 

// updating entity
engine.LoadByID(1, user)
user.Name = "John"
engine.LoadByID(2, user2)
user.Name = "Ivona"
engine.FlushLazy(user, user2)

// deleting entity
engine.LoadByID(2, user)
engine.DeleteLazy(user)

// using Flusher
flusher := engine.NewFlusher()
flusher.Track(user, user2)
flusher.Delete(user3)
flusher.FlushLazy()
```
</code-block>

<code-block title="queries">
```sql
REDIS XAdd orm-lazy-channel event
REDIS XAdd orm-lazy-channel event
REDIS XAdd orm-lazy-channel event
```
</code-block>
</code-group>

Above example adds three events (queries) to redis `orm-lazy-channel` stream. You can easily check statistics of this stream:

```go
statisticsStream := engine.GetEventBroker().GetStreamStatistics(beeorm.LazyChannelName)
statisticsStream.Len // number of events in a stream, both processed and waiting to be processed by stream group.
statisticsStream.OldestEventSeconds // how old (in seconds) is olders query that needs to be executed

statisticsConsumer := engine.GetEventBroker().GetStreamGroupStatistics(beeorm.LazyChannelName, beeorm.BackgroundConsumerGroupName)
statisticsConsumer.Lag // shows how many lazy queries are still in stream waiting to be executed, works only with redis 7
statisticsConsumer.Pending // shows how many lazy queries are now processed by `BackgroundConsumer`
statisticsConsumer.LowerDuration // how old is the oldest query wating in stream to be executed
```

We will explain more above statistics on [stream statistics page](/guide/event_broker.html#stream-statistics).

:::tip
If you see that queries are not executed and `statisticsStream.Len` is growing probably you forgot to run [background consumer](/guide/background_consumer.html) in your application.
:::

:::warning
Remember that `FlushLazy()` is not setting up ID in a new Entity. So if you need ID in your code you must use `Flush()`
instead or enable [UUID](/guide/uuid.html#enabling-uuid) for this entity (recommended).
```go
user := ProductEntity{Name: "Shoe"}
engine.FlushLazy(user)
// bug, user.ID is still zero
c.Redirect(http.StatusTemporaryRedirect, fmt.Sprintf(""https://mysite.com/product/%d/", user.ID)) 

```
:::

## Defining lazy queries pool name

By default BeeORM creates stream in `default` [redis data pool](/guide/data_pools.html#redis-server-pool).
You can provide different pool name by registering stream `beeorm.LazyChannelName` together with `beeorm.BackgroundConsumerGroupName`
consumer group name and your redis pool name, as showed on below example

<code-group>
<code-block title="code">
```go{3}
registry := beeorm.NewRegistry()
registry.RegisterRedis("192.123.11.12:6379", "", 0, "lazy")
registry.RegisterRedisStream(beeorm.LazyChannelName, "lazy", []string{beeorm.BackgroundConsumerGroupName})
```
</code-block>

<code-block title="yaml">
```yml{4,5}
lazy:
    redis: 192.123.11.12:6379
    streams:
        orm-lazy-channel:
          - orm-async-consumer
```
</code-block>
</code-group>

## Lazy Flush Workers

You can define how many SQL queries generated by `engine.FlushLazy()` should be executed at the same time in
parallel. By default `BackgroundConsumer` runs queries in 11 goroutines. You can change it using
`SetLazyFlushWorkers` method:

```go{2}
consumer := beeorm.NewBackgroundConsumer(engine)
consumer.SetLazyFlushWorkers(20)
```

## Error resolver

Using `FlushLazy()` can be tricky. When you are using `FlushLazy()` you must be sure data is validated and query
can be executed in MySQL. Otherwise `BackgroundConsumer` will panic trying executing query and whole redis stream
consumer is blocked until you gonna remove invalid query from redis stream. Look at example below

```go
user := User{Email: "user@mail.com"}
engine.FlushLazy()
```

Now consider column `Email` in table `User` has Unique Index and there is already user with email `user@mail.com`.
In this scenario `BackgroundConsumer` panics and while stream with lazy queries is blocked:

```go
//panics with error "Error 1062 (23000): Duplicate entry 'user@mail.com' for key 'Email'"
beeorm.NewBackgroundConsumer(engine).Digest(ctx)
```

Of course, you should improve your code by checking if email is already in use before you run `engine.FlushLazy()`:

```go
email := "user@mail.com"
if engine.SearchOne(beeorm.NewWhere("Email = ?", email), user) {
  return fmt.Errorf("email %s is already in use", email)
}
user := User{Email: email}
engine.FlushLazy()
```

But in real life you may end in situation where one query in lazy stream is invalid and `BackgroundConsumer` panics.
BeeORM provides method `RegisterLazyFlushQueryErrorResolver` which helps you deal with such situations. Using this method
you can register special functions which are executed (in a order you registered them) when query executed in `BackgroundConsumer` failed and allows you to
deal with this error. If your function returns error it means issue is not solved by this function and `BackgroundConsumer` will try next registered function or will
panic if there are no more registered function. But if you return `nil`instead you are instructing `BackgroundConsumer` that problem is solved and this query should be removed
from lazy stream so `BackgroundConsumer` can continue with next query.

To solve our scenario you may register two functions:

```go
backgroundConsumer := beeorm.NewBackgroundConsumer(engine)

backgroundConsumer.RegisterLazyFlushQueryErrorResolver(func(_ Engine, _ *DB, sql string, queryError *mysql.MySQLError) error {
   errorLogService.LogEror("lazy flush query [%s] faild with error %s", queryError.Error())
   return queryError
})

backgroundConsumer.RegisterLazyFlushQueryErrorResolver(func(_ Engine, _ *DB, sql string, queryError *mysql.MySQLError) error {
   errorLogService.LogEror("lazy flush query [%s] faild with error %s", queryError.Error())
   if queryError.Number == 1062 { //Duplicate entry
     return nil
   }
   return queryError
})
```

As you can see first function logs all failed queries in error log, so developer can review these queries
to find a source of the problem in application code and maybe execute some queries by hand to fix data in database.
This function returns error so `BackgroundConsumer` will execute next registered function.

Second function check if MySQL error code is 1062 (Duplicate entry '%s' for key %d) and if yes then
returns nil instructing `BackgroundConsumer` to remove this query from stream and continue. 

So from now all queries that throws MySQL error code 1062 will be automatically skipped and logged to error log.

## Not supported lazy flush scenarios

There are two scenarios where using `FlushLazy()` is not supported and panics.

One is when you are flushing entity with [on duplicate key update](/guide/crud.html#saving-new-entities) option:

```go
category := &CategoryEntity{Code: "cars", Name: "Cars V2"}
category.SetOnDuplicateKeyUpdate(beeorm.Bind{"Name": "Cars V3"})
//panics with "lazy flush on duplicate key is not supported" error
engine.FlushLazy(categoryCars) 
```

Another one is when you are flushing entity with one-one references that needs to be inserted to database:

```go
category := &CategoryEntity{Code: "cars", Name: "Cars"}
product := &ProductEntity{Name: "BMW 1", Category: category}
//panics with "lazy flush for unsaved references is not supported" error
engine.FlushLazy(product)
```
