# Lazy Flush

Executing `engine.Lazy()` executes all queries to MySQL and Redis immediately.
But in many scenarios you may prefer to run queries asynchronously, in another thread, so your code can continue
without a need to wait a query is executed in database.

BeeORM provides special method `FlushLazy()` which is doing exactly it. Queries to MySQL and Redis are added to special [redis stream](https://redis.io/docs/data-types/streams/) 
called `orm-lazy-channel`. Then [background consumer](/guide/background_consumer.html) is reading these queries and executes them.

Look at example below:

<code-group>
<code-block title="code">
```go{3,10,14,2-}
// adding new entity
user := &UserEntity{FirstName: "Tom", LastName: "Bee", Email: "bee@beeorm.io"}
engine.FlushLazy(user) 

// updating entity
engine.LoadByID(1, user)
user.Name = "John"
engine.LoadByID(2, user2)
user.Name = "Ivona"
engine.FlushLazy(user, user2)

// deleting entity
engine.LoadByID(2, user)
engine.DeleteLazy(user)

// using Flusher
flusher := engine.NewFlusher()
flusher.Track(user, user2)
flusher.Delete(user3)
flusher.FlushLazy()
```
</code-block>

<code-block title="queries">
```sql
REDIS XAdd orm-lazy-channel event
REDIS XAdd orm-lazy-channel event
REDIS XAdd orm-lazy-channel event
```
</code-block>
</code-group>

Above example adds three events (queries) to redis `orm-lazy-channel` stream. You can easily check statistics of this stream:

```go
statisticsStream := engine.GetEventBroker().GetStreamStatistics(beeorm.LazyChannelName)
statisticsStream.Len // number of events in a stream, both processed and waiting to be processed by stream group.
statisticsStream.OldestEventSeconds // how old (in seconds) is olders query that needs to be executed

statisticsConsumer := engine.GetEventBroker().GetStreamGroupStatistics(beeorm.LazyChannelName, beeorm.BackgroundConsumerGroupName)
statisticsConsumer.Lag // shows how many lazy queries are still in stream waiting to be executed, works only with redis 7
statisticsConsumer.Pending // shows how many lazy queries are now processed by `BackgroundConsumer`
statisticsConsumer.LowerDuration // how old is the oldest query wating in stream to be executed
```

We will explain more above statistics on [stream statistics page](/guide/event_broker.html#stream-statistics).

:::tip
If you see that queries are not executed and `statisticsStream.Len` is growing probably you forgot to run [background consumer](/guide/background_consumer.html) in your application.
:::

:::warning
Remember that `FlushLazy()` is not setting up ID in a new Entity. So if you need ID in your code you must use `Flush()`
instead or enable [UUID](/guide/uuid.html#enabling-uuid) for this entity (recommended).
```go
user := ProductEntity{Name: "Shoe"}
engine.FlushLazy(user)
// bug, user.ID is still zero
c.Redirect(http.StatusTemporaryRedirect, fmt.Sprintf(""https://mysite.com/product/%d/", user.ID)) 

```
:::

## Defining lazy queries pool name

By default BeeORM creates stream in `default` [redis data pool](/guide/data_pools.html#redis-server-pool).
You can provide different pool name by registering stream `beeorm.LazyChannelName` together with `beeorm.BackgroundConsumerGroupName`
consumer group name and your redis pool name, as showed on below example

<code-group>
<code-block title="code">
```go{3}
registry := beeorm.NewRegistry()
registry.RegisterRedis("192.123.11.12:6379", "", 0, "lazy")
registry.RegisterRedisStream(beeorm.LazyChannelName, "lazy", []string{beeorm.BackgroundConsumerGroupName})
```
</code-block>

<code-block title="yaml">
```yml{4,5}
lazy:
    redis: 192.123.11.12:6379
    streams:
        orm-lazy-channel:
          - orm-async-consumer
```
</code-block>
</code-group>

## Lazy Flush Workers

You can define how many SQL queries generated by `engine.FlushLazy()` should be executed at the same time in
parallel. By default `BackgroundConsumer` runs queries in 11 goroutines. You can change it using
`SetLazyFlushWorkers` method:

```go{2}
consumer := beeorm.NewBackgroundConsumer(engine)
consumer.SetLazyFlushWorkers(20)
```

:::tip
You should increase this number if `engine.GetEventBroker().GetStreamGroupStatistics(beeorm.LazyChannelName, beeorm.BackgroundConsumerGroupName).Lag` is growing.
:::

## Error resolver

Using `FlushLazy()` is 

## Not allowed actions (ON DUPLIKATE KEY, references)

TODO
